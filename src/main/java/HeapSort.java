public class HeapSort {
    public static void sort(double[] arr){
        int size = arr.length;

        //Построение кучи(перегруппировка данного массива с учётом того,
        // что родительский узел хранится в ячейке массива с индексом i,
        // значит левый дочерний элемент в ячейке с индексом 2*i+1,  правый
        // дочерний элемент - 2*i+2)
        for(int i = size/2-1; i>=0; i--){
            heapify(arr, size, i);
        }

        //Извлечение элементов из кучи
        for(int i = size-1; i>0; i--){

            //Перемещение текущего(самого большого элемента) в конец
            double temp = arr[0];
            arr[0] = arr[i];
            arr[i] = temp;

            //Повторное построение кучи на уменьшенном массиве данных
            heapify(arr, i, 0);
        }
    }

    //Построение двоичной кучи из поддерева(массива arr длинной n) с корневым узлом i
    public static void heapify(double[] arr, int size, int i){
        int largest = i;//Инициализируем наибольший элемент как корень
        int left = 2*i+1;//левый дочерний элемент
        int right = 2*i+2;//правый дочерний элемент

        //Если левый дочерний элемент больше наибольшего, присваиваем его наибольшему
        if(left<size && arr[left]>arr[largest]){
            largest = left;
        }

        //Если правый дочерний элемент больше наибольшего, присваиваем его наибольшему
        if(right<size && arr[right]>arr[largest]){
            largest = right;
        }

        //Если наибольший элемент не является корнем, то меняем их местами(т.к. корнем должен быть самый большой элемент)
        if(largest != i){
            double temp = arr[i];
            arr[i] = arr[largest];
            arr[largest] = temp;

            //Преобразуем в двоичную кучу затронутое поддерево, поскольку были поменяны элементы местами
            heapify(arr, size, largest);
        }
    }
}
